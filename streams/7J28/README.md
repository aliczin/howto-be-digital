---
presentation:
    enableSpeakerNote: true
    theme: black.css
    viewDistance: 3
    slideNumber: true
    #parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'
---

<!-- slide data-notes="" -->

Себестоимость: часть 1

> на небе что и разговоров, как про себестоимость

```bsl
#Использовать delta_lake

Ынтыпрайз.РассчитатьСебестоимость();

```

<!-- slide data-notes="" -->

## Исходный посыл

Чтобы понять как считать себестоимость надо отказаться от себестоимости.

* Себестоимость - это синтезированный термин, и чтобы его автоматизировать, нам нужно его декомпозировать.

> Фактически - это так экономисты закодировали свой пласт знаний. Чтобы никто не догадался

<!-- slide vertical=true -->

На самом деле нам нужно использовать другие домены, а именно

* Временной ряд
* Категориризатор
* Калькулятор

<!-- slide vertical=true -->

Все еще хуже, мы должны понимать что 

* существуют **Понесенные расходы**
* существуют **Учтенные расходы**
* существуют **Плановые расходы**

<!-- slide data-notes="Итак - мы уже понимаем, что есть расходы и больше слова себестоимость не используем, однако" -->

**Кому нужен расчет расходов и зачем ?** 

* Бухгалтерам - чтобы в учете по определенному способу снижать производные показатели.
* Финансовым директорам - чтобы планировать различные инвестиции исходя из точек безубыточности
* Начальнику производства - чтобы планировать комплекс мероприятий по повышению производительности труда


<!-- slide vertical=true -->

> Примечание: ВСЁ есть производство - потому что есть процесс - а процесс есть конвейер.

Это важный момент - для последующий декомпозиции. Даже если просто купи-продай - хочешь ты того или не хочешь, но ты занимаешься "хреновым" но производством

<!-- slide data-notes="" -->

вернемся к

| Домен  | Физический тип хранения  |
|---|---|
| **Понесенные расходы**  |  Временной ряд |
| **Учтенные расходы**  | Временной ряд  |
| **Плановые расходы**  | Календарь  |

<!-- slide data-notes="" -->

Я не зря говорил про роли

- Бухгалтеру нужно распределение расходов по субконто и по периодам 
    - он борется за налоги <!-- .element: class="fragment" data-fragment-index="2" -->
- Финансовому директору нужна на единицу продукции по году
    - он борется за норму прибыльности <!-- .element: class="fragment" data-fragment-index="1" -->
- Начальнику производства нужна по ресурсам (в том числе человеским)
    - он борется за людей (наверное) <!-- .element: class="fragment" data-fragment-index="3" -->

<!-- slide data-notes="" -->

Получается - у нас есть некая телеметрия
Дальше мы должны построить взаимосвязь с бизнес-термином и выдать 

* функцию возвращающую расчетное значение

<!-- slide data-notes="" vertical=true -->


Типа такой

```bsl {.line-numbers}
Функция ПолучитьСебестоимость(Роль)
```

<!-- slide data-notes="" vertical=true  -->

А также такой

```bsl {.line-numbers}
Функция ЗафиксироватьВременнойРядРасходов(ТипРасхода)
```

<!-- slide data-notes="" vertical=true -->

Ну и конечно такой

```bsl {.line-numbers}
Функция ТрансформироватьРядРасходовВСебестоимость(
    РежимТрансформации.Онлайн)
```

<!-- slide data-notes="" -->

Как мы помним - временной ряд сам по себе имеет в виде спецификации

* метаданные <!-- .element: class="fragment" data-fragment-index="1" -->
* атрибуты <!-- .element: class="fragment" data-fragment-index="2" -->
* собственно меняемое значение и его единицу измерения <!-- .element: class="fragment" data-fragment-index="3" -->

менятся сам по себе временной ряд может в системе источнике и мы не имеем на него влияния

<!-- slide data-notes="#Заметка про расходы типа "реальные"" vertical=true -->

Мы купили "сервер", Подключили к системе мониторинга утилизации, получаем `МгновенныйРасход`

```json {.line-numbers}
Расход.Send {
    meta: {
        id: "hp-proliad-2545"
        typeid: "computers"
    },
    atrrs: {
        "longtitude": 64.736520, 
        "latitude": 177.498970
    },
    временныеРяды: {
        "утилизация": 15.3,
        "расходЭлектричества": 110
    }    
}
```

https://yandex.ru/maps/-/CCUUb2XF9C

<!-- slide data-notes="энтропия" vertical=true -->

Хорошо когда данные на "конце" (Edge) качественные и стабильные.

Но в Анадыре может быть и не так ;-)

<!-- slide data-notes="" -->

Итого обращает на себя внимания тот факт, что мы должны добавить в наш **КОНВЕЙЕР** 2 новых потоковых функции

* определение единиц измерения временных рядов
* выстраивание графа отношений между временными рядами - учитывая что модель входных данных меняется
* оповещение о появление нового временного ряда

<!-- slide data-notes="" vertical=true -->


Типа таких


```bsl {.line-numbers}
Функция ОпределитьЕдиницуИзмеренияВременногоРядаРасхода(
    ЭнтропическаяЗаписьРасхода)
```

```bsl {.line-numbers}
Функция ЗаписатьНовыйТипРасходовВГраф()
```

Ну и конечно такой

```bsl {.line-numbers}
Функция НайтиНесвязанныеРебраГрафаРасходов(
    АдминистраторДанныхДляОпвещения)
```

<!-- slide data-notes="" -->

Таким образом все что мы должны сделать, при учете что внешнии системы будет слать в нас странное - это создать 2 конвейера

* Принимающий временные ряды и структурирующий их
* Расссчитывающий значения для разных ролей чтобы обеспечивать выдачу данных

<!-- slide data-notes="" -->

Чтобы не страдать ерундой, делать будем по правильному

* на базе PostgreSQL со стероидами <!-- .element: class="fragment" data-fragment-index="1" -->
* на базе потокового сервера принимающего всё что нужно в режиме реального времени (хотя это скорее NearrealTime) - пусть будет Kafka <!-- .element: class="fragment" data-fragment-index="2" -->
* считать будем круто с клевой математикой - пусть будет Spark  <!-- .element: class="fragment" data-fragment-index="3" -->
* ну а API будем делать по большому - через OpenAPI.V4 <!-- .element: class="fragment" data-fragment-index="4" -->

<!-- slide data-notes="" -->

Будет как то так

```bsl {.line-numbers}
Процедура ПриемникРаходов()
    ПодписатьсяНаПотоки("расходы.*").
        ОбработатьТипыДанных().
        ДосчитатьСебестоимость();
КонецПроцедуры

Процедура ОповещениеОфицераДанных()
    ОбработатьНеКачественныеДомены();
КонецПроцедуры

ФоновыеЗадания.Добавить(ПриемникРаходов);
ФоновыеЗадания.Добавить(ОповещениеОфицераДанных);

СкомпилироватьСайтAPI("src/api");
ЗапуститьОтображениеГрафаСущностей("infra");
```

Обратите внимание - будем только кодить ;-) GY
